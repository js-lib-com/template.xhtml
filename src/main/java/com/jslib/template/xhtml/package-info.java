/**
 * Declarative X(HT)ML templates engine. First thing first: declarative part. This templates engine is indeed declarative. It
 * does not embed programming language into (X)HTML code. And this - beside being much easier to learn and use - comes with important 
 * consequence: a complete separation of logic and data. Declarative nature forces view to deal only with presentation, there is no 
 * chance for developer to mix-in business logic - see code samples.
 * <pre>
 *  &lt;ul data-list="contacts"&gt;
 *      &lt;li&gt;&lt;span data-text="name" /&gt; - &lt;span data-text="phone" /&gt;&lt;/li&gt;
 *  &lt;/ul&gt;
 * </pre>
 * Below is a typical templates engine using embedded Groovy. For a user interface developer seasoned with HTML this code may
 * look a little more difficult to grasp. But the real thing is concern separation: user interface developer need not to know contacts
 * comes from an instance named <code>client</code> and that field name is <code>contact</code>. And because the language allows it, is
 * possible to alter model object values from templates which is bad.   
 * <pre>
 *  &lt;ul&gt;
 *  #{list contacts:client.contacts, as:'contact'}
 *      &lt;li&gt;${contact.name} - ${contact.phone}&lt;/li&gt;
 *  #{/list}
 *  &lt;/ul&gt;
 * </pre>
 * 
 * <ol>
 * <li>natural template
 * <li>strict separation of view from business logic
 * <li>simple syntax that can be understood by graphic designers
 * </ol>
 * 
 * <h3>Temples engine overview</h3>
 * A template is an X(HT)ML file that contains templates operators. An operator is declared
 * into and operates on an {@link js.dom.Element} and has an opcode and exactly one operand. The most common operator is 
 * setter which takes care to set element text content or attribute. A short example may clarify: 
 * <pre>
 *  // model object
 *  class Person {
 *      String description = "person description";
 *      Picture picture = new Picture("images/person.png");
 *  };
 *  
 *  // template fragment
 *  &lt;p data-text="description"&gt;&lt;/p&gt;
 *  &lt;img data-attr="src:picture;title:description;" /&gt;
 * </pre>
 * Templates engine enacts <b>data-text</b> and <b>data-attr</b> operators that set paragraph text to <b>Person</b>
 * <em>description</em>, image source to <em>picture</em> and image tooltip, i.e. its title attribute, also to <em>description</em>.
 * <pre>
 *  &lt;p&gt;person description&lt;/p&gt;
 *  &lt;img src="images/person.png" title="person description" /&gt;
 * </pre>
 * 
 * Templates operators are declared using standard X(HT)ML attributes and uses next syntax:
 * <pre>
 *  operator := 'data' '-' opcode '=' '"' operand '"'
 *  opcode := see <a href="#operators-list">operators list</a>
 *  operand := propertyPath | expression
 *  propertyPath := see <a href="#object-property-path">object property path</a> 
 *  expression := evaluated by operator
 * </pre>
 * One may notice operator opcode is prefixed with <em>data-</em>. This is indeed on purpose: HTML5 allows for element attributes 
 * extensions and extensions name start exactly with that prefix.
 * <p>
 * Since instruction syntax is a subset of supporting template syntax it can be kept into resulting document. This comes with a
 * big advantage: the same instructions can be used to extract model object from documents generated by templates processor.
 * This can be seen as an object oriented alternative to micro-formats. So templates processor can be used for both injection 
 * and extraction of the model object into/from documents.
 * <p>
 * When processing templates, the DOM tree is traversed in synchro with model object graph. DOM is a tree of elements and
 * model is a tree of values; model tree is mapped on elements tree. This does necessarily means those trees are congruent, elements
 * tree can and usually is more complex but its overall structure resemble model tree.    
 * 
 * <pre>
 *                   e1 
 *                  /               
 *     m1          e   
 *    /           / \ 
 *  m0          e0   e
 *    \           \    
 *     m2          \  
 *                  e2 
 * </pre>
 * 
 * Templates engine define a function TE: m -> e defined on model with values on elements, in other words model is domain whereas 
 * elements tree is codomain. Note that TE is not surjective, that is,  not for every element <b>e</b> in the codomain there
 * is an <b>m</b> in the domain such that TE(m) = e.
 * 
 * <h3 id="operators-list">Templates operators list</h3>
 * Templates engine algorithm is generic and operates on operator types, that is, groups of operators. This way adding new operators
 * does not require algorithm update. This operators list is displayed using that types hierarchy. 
 * <p>
 * <table>
 * <tr>
 * <td colspan="2">1. CONDITIONAL - include or exclude DOM branches based on some condition:
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.IfOperator if}
 * <td>if value is empty element branch is not included in resulting document
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.ExcludeOperator exclude}
 * <td>exclude element and its descendants from resulting document; implementation may choose to hide or completely remove the branch
 * 
 * <tr>
 * <td>&nbsp;
 * <tr>
 * <td colspan="2">2. ATTRIBUTE - set specified attribute to value extracted from content:
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.AttrOperator attr}
 * <td>set attributes values; both attributes name and value are specified into expression operand
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.IdOperator id}
 * <td>convenient attribute setter for element ID
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.SrcOperator src}
 * <td>convenient attribute setter for image source
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.HrefOperator href}
 * <td>convenient attribute setter for hyper-references; element should be an anchor or a resource link
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.TitleOperator title}
 * <td>convenient attribute setter for tooltips
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.ValueOperator value}
 * <td>convenient attribute setter for element value; element should be an input or textarea
 * 
 * <tr>
 * <td>&nbsp;
 * <tr>
 * <td colspan="2">3. CONTENT - operates upon element content be it text content or generated children elements:
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.ObjectOperator object}
 * <td>current element is an object with many properties and should have child elements
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.TextOperator text}
 * <td>set element text content
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.HtmlOperator html}
 * <td>set element inner HTML, useful for text formatted with HTML tags
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.NumberingOperator numbering}
 * <td>set element text content accordingly numbering format and item index
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.ListOperator list}
 * <td>current element is a list and should have a child element that is processed as list item
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.OListOperator olist}
 * <td>ordered variant of {@link com.jslib.template.xhtml.Opcode#LIST}, that is, list with numbering
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.MapOperator map}
 * <td>current element is a map and should have two child elements: first processed as map key and the second as value
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.OMapOperator omap}
 * <td>ordered variant of {@link com.jslib.template.xhtml.Opcode#MAP}, that is, map with numbering
 * 
 * <tr>
 * <td>&nbsp;
 * <tr>
 * <td colspan="2">4. FORMATTING - set format instance used to prepare content value before actual insertion:
 * <tr>
 * <td><b>{@link com.jslib.template.xhtml.FormatOperator format}
 * <td>set formatter for value and text content setters
 * </table>  
 * <p>
 * Operators precedence is controller by their types in next order: conditional, inline, attribute, content and scope operators.
 * <h3 id="object-property-path">Object property path</h3>
 * Basically templates operators inject values from content into target document. In order to identify the right
 * piece of information content is regarded as a tree of values; every value can be reached traversing the three,
 * from node to node following a unique path.
 * <pre>
 *  class Person {
 *      String name;
 *      Address address {
 *          Locality locality {
 *              String name;
 *          }
 *      }
 *  }
 * </pre>  
 * In above pseudo-code person and locality names are values; locality name path is <em>.address.locality.name</em> whereas person
 * name is simple <em>.name</em>. Both exemplified paths starts with dot, meaning they are absolute path. Is also possible to use 
 * relative paths, but we need a reference named <b>scope object</b> or simply <b>scope</b>. So, if scope is Address, locality name path 
 * is <em>locality.name</em>; note missing dot from path start. For this reason all operators receive a scope object into parameters 
 * list. Also, template scanning starts with scope root, in our case Person instance; there is a scope operator used to change current scope. 
 * 
 * <h3>Templates implementations</h3>
 * There are two templates engine implementations: serializer and injector. A serializer traverses DOM tree using 
 * depth-first algorithm and serialize every node to a given writer. If current node contains templates operators 
 * execute them. Operator execution act upon model object and result is also serialized to stream. 
 * <pre>
 *  TEMPLATE -> DOM -> TP -> WRITER
 *                      ^
 *                      |
 *                   CONTENT
 * </pre>
 * An injector templates engine also traverses source DOM using depth-first but model object values are injected directly into
 * source DOM, altering it.
 * <pre>                  
 *               |<-----|       
 *               v      |  
 *  TEMPLATE -> DOM -> TP
 *                      ^
 *                      |
 *                   CONTENT   
 * </pre>
 * Currently server side implementation is a serializer and client side is an injector for obvious rationales: server should send back
 * to client documents generated on the fly, serialized on Servlet writer whereas client side should update loaded DOM in order to update
 * user interface. But both support the same operators with exactly the same behavior so that documents generated on server side or on
 * client look exactly the same, of course if generated from the same template. 
 * 
 * 
 * <h3>Experimental Solution</h3>
 * Uses namespace for operators prefix and o:load operator to load content from server.
 * <pre>
 *  &lt;tr xmlns:o="http://js-lib.com/dom" o:load="/rest/contradiction"&gt;
 *      &lt;td&gt;&lt;img o:src="image" o:title="name" /&gt;&lt;/td&gt;
 *      &lt;td o:object="tasks.0" o:css-class="tasks.0:active"&gt;
 *          &lt;p o:text="start" o:format="js.format.StandardDateTime"&gt;&lt;/p&gt;
 *  . . .    
 * </pre>
 * 
 * @author Iulian Rotaru
 * @version 1.0
 */
package com.jslib.template.xhtml;

